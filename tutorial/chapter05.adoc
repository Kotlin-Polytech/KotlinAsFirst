= 5. Разбор и форматирование строк

Распознавание содержимого строки, тем или иным путём полученной от пользователя --
одна из важнейших задач в программировании.
Традиционное название этой задачи -- __разбор__ строки (или текста), либо __парсинг__ (от английского parsing) строки.
Разбираемой строкой может быть как что-то, непосредственно введённое пользователем с клавиатуры,
так и содержимое какого-либо файла, а часто и строчка, пришедшая по сети (например, содержимое HTTP-запроса).
Отметим, что анализ текстов программ также включает разбор текста программы как одну из решаемых задач.

== Разбиение строки на части

Простая задача на эту тему может выглядеть так.
Некоторая строка содержит текущее время в формате "11:34:45", то есть часы, минуты и секунды, разделённые двоеточием.
Написать функцию, которая __разберёт__ эту строку и рассчитает количество секунд, прошедшее с начала дня.
В нашем случае ответ должен быть 11 * 3600 + 34 * 60 + 45 = 41685. Решение на Котлине может выглядеть так:

[source,kotlin]
----
fun timeStrToSeconds(str: String): Int {
    val parts = str.split(":")
    var result = 0
    for (part in parts) {
        val number = part.toInt()
        result = result * 60 + number
    }
    return result
}
----

Данная функция начинается с разбиения строки на части.
Для этой цели мы используем функцию `str.split(":")`, у которой разбиваемая строка является __получателем__,
а аргумент задаёт последовательность символов, по которой происходит разбиение.
Результатом функции `split` является СПИСОК строк, содержащий части исходной строки.
В нашем случае строка содержит два двоеточия, поэтому частей будет три, например, "11", "34" и "45".

Получив части нашей строки -- часы, минуты и секунды -- нам необходимо каждую из них превратить из строки в целое число.
Это преобразование осуществляется оператором `val number = part.toInt()`.
Похожие функции нам уже встречались в уроке 2 -- они использовались для преобразования
целых чисел в вещественные `n.toDouble()` или вещественных в целые `x.toInt()`.
Оказывается, функции `toInt()` и `toDouble()` определены и для получателя типа String.

Мутирующая переменная `result` используется для формирования результата.
В процессе выполнения цикла **for** часы будут умножены на 60 дважды, минуты -- один раз, а секунды оставлены как есть
(проверьте этот факт). В результате мы получим количество секунд, прошедшее с начала дня.

== Исключения

Откройте теперь тестовую функцию `timeStrToSeconds` и попробуйте вызвать исходную функцию для некорректного аргумента --
например, для строки `"AA:00:00"`. Вы увидите сообщение **test failed** со следующим сообщением:

----
java.lang.NumberFormatException: For input string: "AA"

	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at lesson5.task1.ParseKt.timeStrToSeconds(Parse.kt:14)
	at lesson5.task1.Tests.timeStrToSeconds(Tests.kt:11)
----

Произошло так называемое __исключение__.
Исключение -- это особый тип переменных, который в языках Котлин и Java имеет название `Exception`.
У исключений есть множество разновидностей, или __подтипов__, конкретно в данном случае
произошло исключение, тип которого называется `NumberFormatException`, или "исключение формата числа".
Математически мы имеем здесь переменную `e`, причём e &isin; E~NF~ (NumberFormatException),
а E~NF~ &sub; E (Exception).

Переменные с типом "исключение" используются для описания произошедших в ходе программы ошибочных ситуаций.
У таких переменных есть возможность, которой нет у других переменных -- их можно __бросать__ (throw).
В Котлине это делается так:

[source,kotlin]
----
fun throwExample() {
    // Создаём исключение
    val e = NumberFormatException("Description")
    // Бросаем исключение
    throw e
}
----

или просто, без создания промежуточной переменной:

[source,kotlin]
----
fun throwExample() {
    // Создаём И бросаем исключение
    throw NumberFormatException("Description")
}
----

Вызов функции `NumberFormatException("Description")` создаёт исключение.
При этом вначале указывается название типа, а в скобках перечисляются необходимые для создания исключения аргументы.
В данном случае аргумент один -- это строка с описанием произошедшего;
в примере выше таким описанием было `For input string: "AA"`.
Обратите внимание на необычность такой функции --
её имя начинается с большой буквы и полностью совпадает с именем некоторого типа.
Такие функции называются __конструкторами__, поскольку используются для создания новых элементов определённого типа.
Позже мы ещё не раз с ними столкнёмся.

Любое исключение -- это составной тип данных, и созданное исключение можно записать в какую-либо переменную или
сразу же __бросить__ с помощью оператора **throw**.
При этом программа, если в ней не предпринять специальных усилий для обработки этой ситуации,
будет немедленно прервана, на консоль будет выведено сообщение, подобное приведённому выше.

После описания исключения на консоль выводится порядок, в котором происходил вызов функций,
программисты называют его __стек вызовов функций__:

----
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at lesson5.task1.ParseKt.timeStrToSeconds(Parse.kt:14)
	at lesson5.task1.Tests.timeStrToSeconds(Tests.kt:11)
----

Читается стек вызовов обычно снизу вверх следующим образом:

 1. Функция `timeStrToSeconds` из пакета `lesson5.task1` и класса `Tests` в строке 11 файла `Tests.kt` вызвала...
 1. Функцию `timeStrToSeconds` из пакета `lesson5.task1` и класса `ParseKt`, которая в строке 14 файла `Parse.kt`, в свою очередь, вызвала...
 1. Функцию `parseInt` из пакета `java.lang` и класса `Integer`, которая в строке 615 файла `Integer.java`, в свою очередь, вызвала...

и так далее. Читая стек вызовов, надо иметь в виду, что часть функций -- например, `toInt` --
в Котлине являются __встраиваемыми__ (inline) -- такие функции не попадают в стек.
Другая часть функций может находится в библиотеках, в том числе и библиотеках Java -- в частности, `parseInt`.
Обычно, чтобы разобраться в ситуации, достаточно изучения собственных функций.

Обратите внимание, что строчки вроде `Parse.kt:14` IDE подсвечивает синим цветом.
Щелчком на них можно перейти к соответствующей строке. Видно, что там происходит вызов `part.toInt()`.
Из описания исключения можно сделать вывод, что оно произошло для исходной строки `"AA"`,
и понятно, о какой ошибке идёт речь -- эта строка не соответствует никакому десятичному числу.

Поставим себя на минутку на место функции `toInt()`.
Ей передана некоторая строка, из которой следует сделать число.
Если строка действительно соответствует числу, его следует сконструировать и вернуть как результат.
Но что делать, если из строки нельзя сконструировать число?
Мы могли бы вернуть некоторую специальную константу (во многих упражнения предлагалось делать так), но какую?
Любое целое число может быть результатом преобразования какой-либо строки.
Пусть, например, мы выбрали число -1, и пусть при вызове `toInt()` мы получили такой результат.
Как нам узнать -- это произошла ошибка, или же наша строка действительно была равна `"-1"`?
Из-за возможности подобных неоднозначностей программисты придумали __исключения__.

Итак, если ранее функция обязана была всегда сформировать какой-нибудь результат,
то с появлением исключений у неё появилась вторая альтернатива -- бросить исключение.
Такое поведение характерно для многих функций.
Например, при обращении к элементу списка по индексу необходимо,
чтобы индекс находился в пределах от 0 до `list.size - 1`.
В противном случае произойдёт исключение подтипа `IndexOutOfBoundsException`.

Итак, исключения обеспечивают для функций возможность сделать что-то разумное в ситуации,
когда они НЕ МОГУТ корректно сформировать свой результат.
Кроме этого, они обеспечивают возможность для программиста разобраться, что же случилось, и исправить ошибку.
Исправить её можно двумя способами: либо убрать причину возникновения исключения, либо обеспечить его __обработку__.

== Обработка исключений ==

Как предусмотреть возможность появления исключения в программе?
Вернёмся к задаче о преобразовании времени в формате "ЧЧ:ММ:СС" в число секунд, прошедшее с начала дня.
В этой задаче нам известно, что число часов, минут и секунд неотрицательно,
поэтому мы могли бы возвращать результат -1 в случае, когда исходная строка некорректна.
В отличие от функции `toInt()`, в нашем случае -1 секунда не может получиться из любой корректной строки.
Но как вернуть результат -1, если произошло исключение? Для этого исключение необходимо __поймать__ (catch).

[source,kotlin]
----
fun timeStrToSeconds(str: String): Int {
    val parts = str.split(":")
    var result = 0
    try {
        for (part in parts) {
            val number = part.toInt()
            result = result * 60 + number
        }
        return result
    }
    catch (e: NumberFormatException) {
        return -1
    }
}
----

Ловится исключение так.
Часть функции, где может произойти исключение, __оборачивается__ блоком `try { }` --
сравните текст функции с её первоначальным вариантом.
**try** с английского переводится как "попытаться" (выполнить участок программы, в котором может произойти исключение).
После блока **try** записывается один (или несколько) блоков `catch (e: ExceptionType) { }` --
в котором написано, что следует делать, если произошло определённое исключение.
Как только в результате одного из вызовов функций внутри блока **try**
происходит исключение типа `NumberFormatException`,
выполнение блока **try** прерывается и начинает выполняться блок **catch**.
`e: ExceptionType` -- это параметр блока **catch**,
`ExceptionType` указывает его тип -- в нашем случае это `NumberFormatException`.

Выполнение блока **catch** после передачи управления ему происходит обычным образом.
В нашем случае он содержит один оператор `return -1`, который формирует результат функции,
и выполнение её на этом заканчивается.
В общем случае содержимое блока **catch** может быть любым.
После окончания его выполнения, начинает выполняться следующий оператор после **try..catch**, если такой оператор есть.

Ловля и обработка исключений -- очень важный элемент программирования.
Пользуясь чужими программами, вам, скорее всего, не раз приходилось говорить, что программа "упала".
В современном программировании такое "падение" программы чаще всего вызывается именно исключением,
которое возникло, но никем не было поймано и обработано.
Такое исключение приводит к аварийной остановке работы программы, что в промышленном программировании недопустимо.
Принято, что программа должна КОРРЕКТНО реагировать на любые, в том числе некорректные, действия пользователя,
поэтому промышленные программы обычно включают в себя механизмы обработки исключений.

== Форматирование строк

Не менее важной задачей является **представление** определённой информации пользователю.
Здесь мы касаемся лишь маленького кусочка этой задачи -- правильного __форматирования__ строк.
Вспомним ещё раз нашу задачу о преобразовании времени в число секунд и рассмотрим обратную ей.
Пусть дано время в секундах, прошедшее с начала дня, и необходимо сформировать строку в формате "ЧЧ:ММ:СС",
соответствующую данному времени.

Представим себе, что мы дали на эту задачу ответ вроде `"13:8:1"` вместо ожидаемого `"13:08:01"`.
С одной стороны, человек должен быть в состоянии понять и наш ответ,
но с другой стороны, **привычным** для человека является всё-таки формат `"13:08:01"` и,
увидев наш ответ без нулей, он на мгновение придёт в ступор и задумается, а что же это вообще такое --
время или же просто последовательность чисел.
Именно поэтому важно всё-таки соблюдать ожидаемый формат.

Для решения задачи мы могли бы воспользоваться функцией вроде этой:

[source,kotlin]
----
fun twoDigitStr(n: Int) = if (n in 0..9) "0$n" else "$n"
----

которая для однозначных чисел формирует строку с нулём впереди, а для остальных всё оставляет как есть.
Решение с помощью функции `twoDigitStr` выглядело бы так:

[source,kotlin]
----
fun timeSecondsToStr(seconds: Int): String {
    val hour = seconds / 3600
    val minute = (seconds % 3600) / 60
    val second = seconds % 60
    return "${twoDigitStr(hour)}:${twoDigitStr(minute)}:${twoDigitStr(second)}"
}
----

В первых трёх операторах мы рассчитываем текущий час, минуту и секунду путём деления на 60.
В последнем мы формируем требуемую строку, и данная функция работает верно.
Есть только два "но": выглядит последний оператор довольно уродливо,
а кроме того, при форматировании строк может возникать много похожих задач и, казалось бы,
для них должно существовать общее решение.

Таким решением является готовая функция `String.format()`.
В данном случае она может использоваться так:

[source,kotlin]
----
fun timeSecondsToStr(seconds: Int): String {
    val hour = seconds / 3600
    val minute = (seconds % 3600) / 60
    val second = seconds % 60
    return String.format("%02d:%02d:%02d", hour, minute, second)
}
----

Первым аргументом функции является __форматная строка__.
Это обычный строковый литерал (константа), в которой, однако, особый смысл несёт символ процента **%**.
Этот символ вместе с несколькими последующими образует __модификатор формата__,
который функцией `String.format` будет заменён на её следующий аргумент
(`hour` для первого процента, `minute` для второго и `second` для третьего).
В этом смысле модификаторы формата напоминают строковые шаблоны `"$name"`,
но они имеют большую мощность, так как позволяют выбрать ещё и __формат__ подстановки аргумента в строку.

Конкретно `%02d` означает "подставить в строку целое число, заняв НЕ МЕНЬШЕ двух (2) символов
и заполнив НЕДОСТАЮЩИЕ символы (если число однозначное) нулём (0).
Перечислим другие распространённые модификаторы формата:

 * `%d` -- подставить число типа `Int`;
 * `%3d` -- подставить число типа `Int`, заняв не меньше трёх позиций (пустые заполняются по умолчанию пробелами);
 * `%c` -- подставить символ;
 * `%s` -- подставить строку;
 * `%20s` -- подставить строку, заняв не меньше 20 позиций;
 * `%lf` -- подставить число типа `Double` в обычном формате;
 * `%le` -- подставить число типа `Double` в экспоненциальном формате вида 1.3e+4;
 * `%6.2lf` -- подставить число типа `Double` в обычном формате, заняв не меньше шести позиций и используя ровно два знака после запятой.

Полное перечисление возможностей форматной строки выходит за рамки этого пособия.
Довольно полное описание имеется в соответствующей статье Википедии,
см. https://en.wikipedia.org/wiki/Printf_format_string#Syntax или её русскоязычный аналог.

== Упражнения

Откройте файл `srс/lesson5/task1/Parse.kt` в проекте `KotlinAsFirst`. Выберите любую из задач в нём.
Придумайте её решение и запишите его в теле соответствующей функции.
Применяйте функцию `split` для разбора строк.
Для их форматирования применяйте строковые шаблоны или, если их недостаточно -- функцию `String.format()`.

Откройте файл `test/lesson5/task1/Tests.kt`,
найдите в нём тестовую функцию -- её название должно совпадать с названием написанной вами функции.
Запустите тестирование, в случае обнаружения ошибок исправьте их и добейтесь прохождения теста.
Подумайте, все ли необходимые проверки включены в состав тестовой функции, добавьте в неё недостающие проверки.

Решите ещё хотя бы одну задачу из урока 5 на ваш выбор.
Убедитесь в том, что можете решать такие задачи уверенно и без посторонней помощи.
По возможности решите одну из задач, помеченных как "Сложная".

Переходите к следующему разделу.


