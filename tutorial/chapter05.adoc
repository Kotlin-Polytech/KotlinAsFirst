= 5. Ассоциативные массивы aka Maps и множества aka Sets

== Введение

В прошлом уроке мы познакомились с вами с различными структурами данных, которые предназначены для хранения упорядоченной последовательности элементов.
Понятно, что это далеко не единственный тип структур данных, которые существуют, и сегодня мы с вами познакомимся с двумя новыми структурами данных.

Чтобы понять первую структуру данных --- **ассоциативный массив** --- далеко ходить не надо, достаточно вспомнить о такой штуке как толковый словарь.
Он связывает элементы отношением "ключ"-"значение": для определенных слов (ключей) он содержит их описание (значения), для всех остальных --- не содержит ничего.
Подобной структурой обладают, на самом деле, многие вещи: набор товаров с их ценами, список контактов в телефоне, рестораны и рейтинги, и т.д.
Основная операция, которую они поддерживают, --- это достать значение, соответствующее интересующему нас ключу, т.е. то, что вы делаете, когда ищете значение неизвестного вам слова в словаре.

Ассоциативный массив является обобщенным способом представить подобное отношение.
Давайте на следующем примере посмотрим, как с ним можно работать.
Представим, что нам необходимо посчитать стоимость нашего списка покупок для заданного набора товаров.
Сделать это можно при помощи следующей функции.

[source,kotlin]
----
fun shoppingListCost(
        shoppingList: List<String>,
        costs: Map<String, Double>): Double {
    var totalCost = 0.0

    for (item in shoppingList) {
        val itemCost = costs[item]
        if (itemCost != null) {
            totalCost += itemCost
        }
    }

    return totalCost
}
----

Что мы здесь видим?
Наша функция принимает на вход список покупок: параметр `shoppingList` типа `List<String>` --- и набор цен для товаров: параметр `costs` типа `Map<String, Double>`.
Данный **параметризованный тип** `Map<Key, Value>` и является типом ассоциативного массива, у которого типовой параметр `Key` задает тип ключей, а `Value` --- тип значений.
В нашем случае набор товаров с ценами имеет тип `Map<String, Double>`, т.е. для названия товара содержит его цену в виде действительного числа.

Для того, чтобы считать общую стоимость выбранного набора товаров, мы заводим новую изменяемую переменную `totalCost`, которая изначально равна нулю и которую мы возвращаем как результат в конце функции при помощи `return`.
После этого мы проходимся по списку покупок при помощи цикла `for` и для каждой покупки пытаемся достать ее цену из нашего ассоциативного массива при помощи операции индексирования.
В отличии от индексирования для списка, операция **индексирования** `map[key]` для ассоциативного массива пытается достать элемент не по какому-то целочисленному индексу, а по ключу соответствующего типа --- в нашем случае, по названию товара, т.е. строке.

А вот дальше мы знакомимся с такой очень интересной вещью как `null`.
Как мы отметили раньше, ассоциативный массив содержит пары "ключ"-"значение", однако для некоторых ключей соответствующего им значения может не быть.
Вместе с тем, просто так вернуть *"ничего"* мы не можем.
Как раз для таких ситуаций и необходим объект `null` --- операция индексирования для ассоциативного массива возвращает `null` в случае, если для заданного ключа нет значения. После того, как мы проверили, что для товара есть его стоимость (`itemCost != null`), мы добавляем ее к общей стоимости набора; в противном случае мы считаем, что данная покупка просто игнорируется.

Попробуем написать тесты для нашей функции.

[source,kotlin]
----
@Test
fun shoppingListCostTest() {
    val itemCosts = mapOf(
            "Хлеб" to 50.0,
            "Молоко" to 100.0
    )
    assertEquals(
            150.0,
            shoppingListCost(
                    listOf("Хлеб", "Молоко"),
                    itemCosts
            )
    )
    assertEquals(
            150.0,
            shoppingListCost(
                    listOf("Хлеб", "Молоко", "Кефир"),
                    itemCosts
            )
    )
    assertEquals(
            0.0,
            shoppingListCost(
                    listOf("Хлеб", "Молоко", "Кефир"),
                    mapOf()
            )
    )
}
----

Как видно из тестов, для **создания** ассоциативного массива может использоваться функция `mapOf()`, которая принимает на вход список **пар** "ключ"-"значение" типа `Pair<A, B>` (в нашем случае, `Pair<String, Double>`).
Для создания пары можно использовать либо конструкцию `Pair(a, b)`, либо запись `a to b`, обе из которых создадут пару из `a` и `b`.
Для того, чтобы обратиться к первому или второму элементу пары `pair`, следует использовать запись `pair.first` или `pair.second` соответственно.

В нашем случае мы создаем пары из названия товара и его стоимости (хлеб за 50.0 и молоко за 100.0), после чего собираем из них ассоциативный массив.
Затем мы проверяем три случая:

* Список покупок содержит хлеб и молоко, и общая стоимость должна быть равна 150.0
* Список покупок, кроме хлеба и молока, содержит еще кефир, но --- так как его стоимости мы не знаем --- мы его игнорируем, и общая стоимость все равно должна быть равна 150.0
* Для какого-то списка покупок с *пустым* ассоциативным массивом (мы не знаем ни одной цены товара) общая стоимость должна быть равна 0.0

В третьем случае мы создаем пустой ассоциативный массив при помощи функции `mapOf()` без аргументов.
Типовые параметры в данном случае компилятор Котлина понимает из того, какой тип должен быть у второго аргумента функции `shoppingListCost`, поэтому их можно не указывать.

== Распространённые операции над ассоциативными массивами

Рассмотрим основные операции, доступные над ассоциативными массивами

* `map[key] / map.get(key)` возвращает значение для ключа `key` или `null` в случае, если значения нет
* `map.size / map.count()` возвращает количество пар "ключ"-"значение" в ассоциативном массиве
* `map + pair` возвращает новый ассоциативный массив на основе `map`, в который добавлено (или изменено) значение ключа, соответствующее паре "ключ"-"значение" из `pair`
* `map - key` возвращает новый ассоциативный массив на основе `map`, из которого, наоборот, удалено значение ключа `key`
* `map1 + map2` собирает два ассоциативных массива в один, причем пары "ключ"-"значение" из `map2` вытесняют значения из `map1`
* `map - listOfKeys` возвращает новый ассоциативный массив на основе `map`, в котором нет ключей из списка `listOfKeys`
* `map.getOrDefault(key, defaultValue)` является расширенной версией операции индексирования. В случае, если в `map` есть значение для ключа `key`, данное выражение вернет его; если значения нет, то будет возвращено значение по умолчанию `defaultValue`.
* `key in map / map.contains(key) / map.containsKey(key)` возвращает `true`, если `map` содержит значение для ключа `key` и `false` в противном случае
* `map.containsValue(value)` возвращает `true`, если `map` содержит значение `value` для хотя бы одного ключа и `false` в противном случае

== Изменяемый ассоциативный массив

Как и в случае со списками, обычный ассоциативный массив (ОАМ) нельзя изменить; если вы хотите иметь такую возможность, то следует использовать изменяемый ассоциативный массив (ИАМ) типа `MutableMap<Key, Value>`.
Аналогично `List` и `MutableList`, ИАМ расширяет ОАМ, т.е. объект ИАМ может использоваться везде, где нужен ОАМ, --- в подобных местах вы просто не будете использовать его возможности по модификации.

ИАМ предоставляет следующие основные возможности по модификации.

* `map[key] = value` **изменяет** имеющееся значение для заданного ключа или **добавляет** новую пару "ключ"-"значение" в случае, если ключ `key` не был связан в `map`
* `map.remove(key)` **удаляет** пару, связанную с ключом `key`

Давайте, как и раньше, попробуем изучить возможности ИАМ на следующем примере: из телефонной книги (набора пар "ФИО"-"телефон") следует убрать все записи, не относящиеся к заданному коду страны.
Сделать это можно, например, следующим образом.

[source,kotlin]
----
fun filterByCountryCode(
        phoneBook: MutableMap<String, String>,
        countryCode: String) {
    val namesToRemove = mutableListOf<String>()

    for ((name, phone) in phoneBook) {
        if (!phone.startsWith(countryCode)) {
            namesToRemove.add(name)
        }
    }

    for (name in namesToRemove) {
        phoneBook.remove(name)
    }
}
----

Данную функцию можно разбить на две логические части.
Первым делом мы проходимся по всем записям в нашей записной книжке и отбираем те из них, у которых телефон начинается с кода, отличного от заданного в параметре `countryCode`.
Для этого мы используем функцию `str.startsWith(prefix)`, которая возвращает `true` в случае, если строка `str` **начинается** со строки `prefix`, и `false`, если это не так.
Все имена, которые следует удалить, мы записываем в изменяемый список `namesToRemove`.

Обратите внимание на форму заголовка цикла: так как ассоциативный массив является набором пар, при помощи такого синтаксиса мы можем сразу разбить элемент-пару на две отдельные переменные, доступные в теле цикла. Такое разбиение называется *разрушающим присваиванием* и может применяться к различным объектам, представляющим собой набор элементов, в частности, к спискам или парам. Два альтернативных (и более многословных) способа написать данный цикл приведены ниже.

[source,kotlin]
----
fun filterByCountryCode(
        phoneBook: MutableMap<String, String>,
        countryCode: String) {
    val namesToRemove = mutableListOf<String>()

    for (entry in phoneBook) {
        val (name, phone) = entry
        if (!phone.startsWith(countryCode)) {
            namesToRemove.add(name)
        }
    }

    for (name in namesToRemove) {
        phoneBook.remove(name)
    }
}
----

[source,kotlin]
----
fun filterByCountryCode(
        phoneBook: MutableMap<String, String>,
        countryCode: String) {
    val namesToRemove = mutableListOf<String>()

    for (entry in phoneBook) {
        val name = entry.key
        val phone = entry.value
        if (!phone.startsWith(countryCode)) {
            namesToRemove.add(name)
        }
    }

    for (name in namesToRemove) {
        phoneBook.remove(name)
    }
}
----

После того, как мы собрали все имена, которые следует удалить, мы это и делаем при помощи функции `map.remove(key)`.
В итоге, после вызова нашей функции с побочным эффектом в переданном ИАМ останутся только записи, у которых номер телефона начинается с нужного нам кода страны.

Тесты для нашей функции выглядят следующим образом.

[source,kotlin]
----
@Test
@Tag("Example")
fun filterByCountryCode() {
    val phoneBook = mutableMapOf(
            "Quagmire" to "+1-800-555-0143",
            "Adam's Ribs" to "+82-000-555-2960",
            "Pharmakon Industries" to "+1-800-555-6321"
    )
    
    filterByCountryCode(phoneBook, "+1")
    assertEquals(2, phoneBook.size)

    filterByCountryCode(phoneBook, "+1")
    assertEquals(2, phoneBook.size)

    filterByCountryCode(phoneBook, "+999")
    assertEquals(0, phoneBook.size)
}
----

Сперва мы при помощи функции `mutableMapOf` создаем ИАМ, в котором есть три записи, две для кода +1 и одна для кода +82.
Затем мы пробуем отфильтровать записи по указанным кодам, корректность же проверяем, сравнивая получившийся размер ИАМ с ожидаемым.
Более правильно, конечно же, было бы сравнивать обновленное значение с эталонным ИАМ, однако инициализация эталона занимает дополнительные 3-4 строчки для каждой проверки, поэтому мы немножечко схитрили таким образом.
Если запустить наши тесты, то мы увидим, что они успешно проходят.
При желании вы можете попробовать модифицировать тесты так, чтобы сравнивать результат с эталоном, и посмотреть, изменится ли результат тестирования.

К этому моменту у вас, скорее всего, возник следующий, довольно очевидный вопрос --- а зачем наша реализация такая сложная?
Почему нельзя сразу убирать записи из ИАМ внутри цикла, который перебирает его записи?
Давайте попробуем и посмотрим, что получится в таком случае.

[source,kotlin]
----
fun filterByCountryCode(
        phoneBook: MutableMap<String, String>,
        countryCode: String) {
    for ((name, phone) in phoneBook) {
        if (!phone.startsWith(countryCode)) {
            phoneBook.remove(name)
        }
    }
}
----

Код стал короче и понятнее, вот только при попытке запустить тесты они упадут с ошибкой `java.util.ConcurrentModificationException`.
Название ошибки тонко намекает нам, в чем проблема, --- мы пытаемся перебирать элементы структуры данных и **одновременно** изменять эту самую структуру данных.
В этом мы подобны дровосеку, который решил забраться на сук и срубить его таким образом, --- "ну а что такого, удобно же!"
К сожалению, как и в жизни, в программировании подобные чудеса не работают --- очень многие структуры данных (в том числе, и ИАМ) не позволяют вам одновременно перебирать и изменять свои элементы.
Именно поэтому наша реализация состояла из двух отдельных частей: мы сперва собрали те элементы, что требуется удалить, а потом их удалили.

== Распространённые операции над изменяемым ассоциативными массивами

Рассмотрим основные операции, доступные над изменяемыми ассоциативными массивами.

* `map.clear()` удаляет все записи из данного ИАМ
* `map[key] = value / map.put(key, value)` добавляет или изменяет соответствующую пару "ключ"-"значение"
* `map.putAll(otherMap)` добавляет в ИАМ `map` все пары из `otherMap`, в случае одинаковых ключей значения из `otherMap` перезаписывают значения из `map`
* `map.remove(key)` удаляет пару для ключа `key`

== Преобразования между ОАМ и ИАМ

TODO

== Множества

== Распространенные операции над множествами

== Операции над `null`

== Упражнения

Откройте файл `srс/lesson5/task1/Map.kt` в проекте `KotlinAsFirst`.
Выберите любую из задач в нём.
Придумайте её решение и запишите его в теле соответствующей функции.

Откройте файл `test/lesson5/task1/Tests.kt`, найдите в нём тестовую функцию -- её название должно совпадать с названием написанной вами функции.
Запустите тестирование, в случае обнаружения ошибок исправьте их и добейтесь прохождения теста.
Подумайте, все ли необходимые проверки включены в состав тестовой функции, добавьте в неё недостающие проверки.

TODO(Написать про сами задачки)

Переходите к следующему разделу.
