= 4.5. Хранение данных в памяти компьютера

В этом разделе мы поговорим о том, как различные элементы программы сохраняются в памяти PC.
Поскольку данное пособие посвящено Котлину как JVM-языку, они сохраняются в памяти JVM как виртуального компьютера.
Тем не менее, организация памяти JVM имеет немало общего с организацией памяти настоящего компьютера.
Поговорим об этом подробнее.

== Биты, байты и килобайты

Единицей измерения информации (например, хранящейся в памяти или на диске) является __бит__ --
элементарная ячейка, имеющая всего два состояния (0 и 1, либо **true** и **false**).
Биты объединяеются в __байты__ -- в одном байте 2^3^ = 8 бит.
Байты, в свою очередь, объединяются в __килобайты__ (Кб) -- в одном килобайте 2^10^ = 1024 байт.
Обратите внимание -- не 1000 байт, а именно 1024 байт,
поскольку компьютеру удобнее, чтобы данные размерности были степенями двойки.
В свою очередь, в одном мегабайте (Мб) 1024 Кб, в одном гигабайте (Гб) 1024 Мб, в одном терабайте (Тб) 1024 Гб.

== Системы счисления

При хранении чисел в компьютере используется не привычная человеку десятичная система счисления,
а более удобная для компьютера двоичная система. При этом используется всего две цифры: 0 и 1.
К примеру, число 75 в двоичной системе представляется как
`1001011 = 1 х 64 + 0 х 32 + 0 х 16 + 1 x 8 + 0 x 4 + 1 x 2 + 1 x 1`.

Поскольку двоичная запись числа является очень длинной, иногда (для удобства связи между человеком и компьютером)
программисты применяют восьмеричную системму счисления (в ней восемь цифр от 0 до 7)
и шестнадцатеричную систему счисления (в ней, помимо традиционных цифр от 0 до 9,
используются цифры a = 10, b = 11, c = 12, d = 13, e = 14, f = 15).
Удобство состоит в том, что одной восьмеричной цифре соответствует ровно три двоичных -- к примеру, 5 = 101,
а одной шестнадцатеричной -- ровно четыре двоичных, к примеру, b = 1011.
75 представляется как 113 в восьмеричной и как 4b в двоичной системе счисления.

Шестнадцатеричную константу в Котлине можно записать с префиксом `0x`: к примеру, `0x4b`.
Восьмеричные константы в Котлине не поддерживаются, а двоичные начинаются с префикса `0b`: к примеру, `0b1001011`.
Подробнее о системах счисления и способах перевода чисел из одной системы в другую можно прочитать в статьях Википедии
"Система счисления" и "Позиционная система счисления".

== Целые числа

Целые числа типа **Int** занимают в памяти четыре байта, или 32 бита,
при хранении используется двоичная система счисления.
Модуль числа занимает 31 бит из 32,
старший бит занимает знак (он равен 0 для положительных и -1 для отрицательных чисел).
Модуль положительных чисел хранится обычным образом, а отрицательных -- в так называемом __дополнительном коде__.
При этом вместо модуля числа `|x|` в памяти хранится значение `2^31^ - |x|`,
например, `2^31^ - 1` для числа `-1` или `0` для числа `-2^31^`.
Использование дополнительного кода позволяет упростить операции сложения и вычитания чисел для компьютера.

Помимо типа **Int**, в Котлине имеется ещё три целочисленных типа, а именно:

 * **Byte** -- целое число от -128 до 127, занимает один байт;
 * **Short** -- целое число от -32768 до 32767, занимает два байта;
 * **Long** -- целое число от `-2^63^` до `2^63^ - 1`, занимает восемь байт.

Подобные целые числа устроены по тому же принципу, что и числа типа **Int**.
Следует иметь в виду, что при работе с типом **Long** нельзя использовать литералы типа **Int**:

[source,kotlin]
----
val long1: Long = 42  // Error!
val long2: Long = 42L // OK!
----

Вместо них используются литералы типа **Long** с суффиксом `L`.

Как правило, в программах используется именно тип **Int** для хранения целых чисел.
Исключения составляют следующие случаи:

 * когда диапазон типа **Int** недостаточен для целей программы, следует использовать **Long**;
 * когда требуется сохранить __большое__ (измеряемое, минимум, десятками тысяч) количество чисел с маленьким диапазоном -- следует использовать **Byte** или **Short** для экономии памяти.

== Вещественные числа

Вещественные числа хранятся в памяти в так называемом __экспоненциальном__ формате `M * 2^E^`.
При этом часть бит выделяется на хранение мантиссы `M` (она находится в ограниченном диапазоне, обычно от 0.5 до 1),
а другая часть бит -- на хранение порядка `E`.
Как мантисса, так и порядок хранятся в двоичной системе счисления, причём один бит всегда выделяется под знак.

В Котлине имеется два вещественных типа.
Один из них, уже известный нам **Double**, занимает в памяти восемь байт.
При этом 53 бита выделяется на мантиссу, а 11 бит на порядок.
Более короткий тип **Float** занимает четыре байта: 24 бита на мантиссу и 8 бит на порядок.

Вещественные литералы по умолчанию имеют тип **Double**.
Для того, чтобы создать литерал типа **Float**, необходимо использовать суффикс `F`:

[source,kotlin]
----
val f1: Float = 1.0  // Error!
val f2: Float = 1.0F // OK!
----

Тип **Double** является рекомендуемым для хранения вещественных чисел.
Тип **Float** следует использовать, если чисел требуется много, а его точности достаточно.

== Символы

Символы в Котлине используют тип **Char** и занимают в памяти два байта.
Вместо символа в памяти хранится его __код__ -- номер данного символа в таблице кодировки Юникод.
Тип **Char** поддерживает только символы из так называемого базового многоязыкового диапазона (Basic Multilingual Plane),
номера которых находятся в интервале от 0 до 2^16^ - 1.
Дополнительные символы с номерами более 2^16^ - 1 могут быть использованы следующим образом:

 * для хранения кода символа может быть использован тип **Int**;
 * для представления такого символа внутри строки используются два элемента типа **Char**, идущих подряд.

Напомним, что символьные константы в Котлине записываются в одинарных кавычках.
Для представления специальных символов используется экранирование, например:

 * `'\t'` -- табуляция;
 * `'\n'` -- новая строка;
 * `'\r'` -- возврат каретки (этот и предыдущий символ остались от эпохи пишущих машинок, которым, чтобы начать вывод с новой строки, было необходимо выполнить две операции -- __возврат каретки__ к началу строки и перевод каретки на __новую строку__);
 * `'\''` -- одинарная кавычка;
 * `'\"'` -- двойная кавычка;
 * `'\\'` -- обратный слэш;
 * `'\$'` -- доллар.

Символы, отсутствующие на клавиатуре, могут быть также заданы с помощью шестнадцатеричного номера в таблице Юникод,
например, `'\uFF00'` -- символ с номером `FF00`.

== Значения и ссылки

В Котлине существует два способа хранения переменных (параметров) в памяти JVM: хранение значений и хранение ссылок.
В любом из этих способов для переменной выделяется ячейка памяти, размер которой зависит от типа переменной,
но не превышает 8 байт.

При хранении __значений__ в эту ячейку помещается значение переменной --
так обычно (строго говоря, не всегда) происходит с переменными целочисленного, вещественного и символьного типа.
При изменении значения переменной изменяется и содержимое соответствующей ей ячейки.

При хранении __ссылок__ в ячейку переменной помещается ссылка,
при этом значение (содержимое) переменной хранится в специальном участке памяти JVM -- __куче__ (heap).
Каждому используемому участку памяти кучи соответствует определённый номер,
и как раз этот номер и используется в качестве __ссылки__.
То есть, при хранении ссылок для чтения значения переменной необходимо выполнить не одно, а два действия:

 * прочитать номер участка в куче из ячейки переменной;
 * по этому номеру обратиться к куче и прочитать значение переменной.

Хранение ссылок используется для всех составных и нестандартных типов, в частности, для строк, массивов, списков.
При изменении переменной в результате выполнения оператора вроде `v = ...` изменяется ссылка. Например:

[source,kotlin]
----
fun foo() {
    // [1, 2, 3] хранится в участке кучи с номером 1, a хранит номер 1
    val a = listOf(1, 2, 3)
    // [4, 5] хранится в участке кучи с номером 2, b хранит номер 2
    var b = listOf(4, 5)
    // Присваивание ссылок: b теперь хранит номер 1
    b = a
}
----

Обратите внимание, что после выполнения трёх приведённых операторов в участке кучи с номером 2 хранится список [4, 5],
но ни одна переменная не хранит ссылку на этот участок.
Подобный участок через некоторое время будет найден и уничтожен специальной программой JVM --
__сборщиком мусора__, он же Garbage Collector.

Такие типы, как **String** или **List**, не предполагают возможность изменения **содержимого** переменной.
Опять-таки при попытке выполнить оператор вида `s = ...` изменится ссылка. Например:

[source,kotlin]
----
fun foo() {
    // Alpha: участок с номером 1
    val a = "Alpha"
    // Beta: участок с номером 2
    var b = "Beta"
    // Тоже номер 2
    val c = b
    // Формируем Alpha + Beta = AlphaBeta: участок с номером 3
    b = a + b
}
----

При сложении `a` и `b` будет создана новая строка AlphaBeta и размещена в участке памяти с номером 3.
После этого номер 3 будет записан в переменную `b`. Отметьте, что `c` по-прежнему хранит номер 2, а `a` -- номер 1.

Особенно интересна ситуация с типом **MutableList**, который позволяет изменять и содержимое переменной тоже.
Например:

[source,kotlin]
----
fun foo() {
    // Участок с номером 1
    val a = mutableListOf(1, 2, 3)
    // Тоже номер 1
    val b = a
    // Изменение содержимого участка с номером 1: теперь это [1, 2, 5]
    b[2] = 5
    println(a[2]) // 5 (!)
}
----

После выполнения оператора `b[2] = 5` участок памяти с номером 1 будет хранить список `[1, 2, 5]`.
Поскольку в переменной `a` хранится тот же номер 1, то вывод на консоль `a[2]` приведёт к выводу числа 5,
хотя раньше этот элемент списка хранил значение 3.

Подобный принцип используют и функции, имеющие параметр с типом **MutableList**:

[source,kotlin]
----
fun invertPositives(list: MutableList<Int>) {
    for (i in 0..list.size - 1) {
        val element = list[i]
        if (element > 0) {
            list[i] = -element
        }
    }
}

fun test() {
    // Участок номер 1
    val a = mutableListOf(1, -2, 3)
    invertPositives(a)
    println(a) // [-1, -2, -3]
}
----

При вызове `invertPositives` номер 1 будет переписан из аргумента `a` в параметр `list`.
После этого функция `invertPositives` изменит содержимое списка, используя данный номер,
и вызов `println(a)` выведет `[-1, -2, -3]` на консоль.