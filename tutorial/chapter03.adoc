= 3. Рекурсии и циклы

Почти все реальные задачи требуют для своего решения не только ветвлений,
но и многократного повторения однотипных действий.
Простым примером такой задачи является вычисление факториала `factorial(n) = n!`.
Напомним, что факториал натурального числа `n` равен произведению всех чисел от 1 до `n`.
По принятому соглашению, `0! = 1` и `1! = 1`, факториал от отрицательного числа не определён.

Наиболее простым для построения программной реализации является **индуктивное** определение факториала,
согласно которому `n! = n(n-1)!`. Базой индуктивного определения служат соглашения о значении `0!` и `1!`.
На Котлине подобное определение реализуется следующим образом:

[source,kotlin]
----
fun factorial(n: Int): Double = if (n < 2) 1.0 else n * factorial(n - 1)
----

Здесь мы использовали приём программирования под названием __рекурсия__.
Для вычисления результата функции **factorial** происходит вызов этой же функции, но с меньшим значением аргумента.
Рано или поздно условие **if (n < 2)** окажется выполненным, и значение функции будет вычислено.
Обратите внимание, что тип результата функции указан как **Double**.
Попробуйте понять, что произойдёт, если **Double** заменить на **Int**, а литерал **1.0** на **1**.

Возможна также реализация итеративного определения, а именно `n! = 1 * 2 * ... * (n-1) * n`.
Для этого необходимо использовать __циклы__;
наиболее распространённым в Котлине является цикл **for**, который подходит и для этой задачи.
Реализация будет выглядеть так:

[source,kotlin]
----
fun factorial(n: Int): Double {
    // Мутирующая переменная (var)
    var result = 1.0
    for (i in 1..n) {
        result = result * i
    }
    return result
}
----

Конструкция **for (i in 1..n) { ... }** читается как "Для всех i в интервале от 1 до n (выполнить) ...".
В данной конструкции объявляется __параметр__ цикла **for**, которому даётся имя **i**.
Цикл **for** будет выполнен **n** раз, то есть произойдёт **n** __итераций__.
На каждой __итерации__ параметр **i** будет иметь **различные** значения -- от 1 до **n**.

Строчкой выше объявлена так называемая __мутирующая__ переменная **result**.
Для её объявления мы использовали ключевое слово **var** (variable) --
в отличие от **val** (value) для обычных переменных.
Мутирующая переменная получает значение 1.0 при её объявлении,
но в процессе выполнения функции она может **изменять** своё значение.

Оператор **result = result * i** выполняет так называемое __присваивание__ мутирующей переменной другого значения.
При этом вначале берётся её прежнее значение (например, 2.0 на 3-й итерации цикла),
оно умножается на значение параметра **i** (3 на 3-й итерации цикла)
и результат (6.0) __присваивается__ переменной **result**.
Если бы мы объявили переменную **result** как **val result = 1.0**,
то в этой строчке функции мы получили бы ошибку:

```
Val cannot be reassigned
```

В последнем операторе **return result** определяется окончательный результат вычисления факториала.

Откройте теперь файл `srс/lesson3/task1/Loop.kt` в проекте `KotlinAsFirst` в IDE и внимательно посмотрите
на определение функции **factorial** вверху файла.
Внимательные читатели обнаружат, что оператор **result = result * i** подчёркнут серой волнистой чертой.
Если навести на него указатель мыши, мы увидим сообщение "Replace with *= operator", то есть "Заменить оператором *=".
Нажмите Alt+Enter, вы увидите контекстное меню с символом лампочки и командой "Replace with *= operator".
Нажмите Enter, и IDE выполнит замену, которую предлагает. Мы получим следующий текст функции:

[source,kotlin]
----
fun factorial(n: Int): Double {
    // Мутирующая переменная (var)
    var result = 1.0
    for (i in 1..n) {
        result *= i
    }
    return result
}
----

Оператор `*=` относится к большой группе __модифицирующих__ операторов и выполняет **домножение**
текущего значения переменной **result** на значение параметра **i**.
Аналогично ему работают операторы `+=`, `-=`, `/=`, `%=` и некоторые другие.