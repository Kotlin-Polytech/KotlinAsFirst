= Основные понятия

== Функции

Функцией в программировании называется законченный участок программы, решающий определённую задачу --
обычно это часть большой задачи, которую решает программа в целом,
хотя в простых случаях написание программы сводится к написанию одной функции.
Как и у функции в математическом смысле, у функции в программировании есть входы (параметры), выход (результат)
и определение, указывающее, как рассчитывается значение выхода по заданным значениям входов.

Определение простых функций на Котлине мало отличается от определения математических функций.
Рассмотрим для примера математическую функцию f(x) = x^2^. На Котлине она будет записана так:

[source,kotlin]
----
fun f(x: Int) = x * x
// или
fun f(x: Double) = x * x
----

В этом определении **fun** является __ключевым словом__, с которого начинается определение любой функции в Котлине.
**f** -- это __имя__ функции, **x** -- __параметр__ функции,
**= x * x** -- __тело__ функции, определяющее, как следует вычислять её __результат__.

Поскольку __операция__ вычисления квадрата числа в Котлине отсутствует, результат вычисляется как произведение **x * x**.
В Котлине присутствуют ещё ряд стандартных __операций__, перечислим некоторые из них:

 * сложение +
 * вычитание -
 * умножение *
 * деление /
 * остаток от деления %
 * круглые скобки () для повышения приоритета операций

Строчка, начинающаяся с символов **//**, является так называемым комментарием -- он предназначен
для лучшего понимания текста программы человеком и никак не влияет на поведение функции или программы.
В Котлине возможны также скобочные комментарии, например:

[source,kotlin]
----
/*
 Здесь будет длинная и сложная функция
 с несколькими параметрами
*/

// Скобочный комментарий начинается с символов /* и заканчивается символами */
----

=== Типы параметров / результата функций

Нотация **: Int** или **: Double** задаёт так называемый __тип__ параметра **x** и требует пояснения.
__Тип__ в программировании подобен области допустимых значений в математике;
математически, запись **x: Int** близка к записи x &isin; Z, а **x: Double** соответственно x &isin; R.
Присутствие в определении функции типов параметров в Котлине **обязательно**;
наличие типов позволяет функции "понять", для каких входов она применима,
а для каких её использование является ошибкой.

Заметим, что __тип__ имеется не только у параметров функции, но и у её результата.
Полная запись функции возведения в квадрат в Котлине (для целого параметра) выглядит следующим образом:

[source,kotlin]
----
fun f(x: Int): Int = x * x
----

Здесь нотация **: Int** перед знаком равенства задаёт тип результата функции.
В Котлине в некоторых случаях **необязательно** записывать тип результата функции явно,
поскольку функция сама может __вывести__ этот тип, зная типы своих параметров.
В данном случае известно, что произведение целого числа на целое также даст целое число,
что позволяет использовать сокращённую форму записи без указания типа результата.

В Котлине определяется некоторое количество стандартных типов;
помимо них, программист имеет право определять свои типы, используя так называемые __классы__ (о них речь пойдёт позже).
На первых порах нам потребуются следующие стандартные типы:

 * Int -- целое число в диапазоне от -2^31^ до 2^31^-1
 * Double -- вещественное число в диапазоне (примерно) от -1.7 * 10^308^ до 1.7 * 10^308^, имеющее точность в (примерно) 15 десятичных цифр
 * Boolean -- так называемый __логический__ или __булевский__ тип с ровно двумя возможными значениями -- **true** и **false**
 * Char -- символ (одиночный), например **Z** или **Я**; значением может являться любой символ, присутствующий в таблице "Unicode", с кодом от 0 до 2^16^-1
 * String -- строка, состоящая из любого количества (в том числе из нуля) одиночных символов

Целые и вещественные числа устроены по-разному.
Например, целые числа сохраняются в памяти компьютера **точно**, а вещественные числа -- **приближённо**.
Некоторые операции и функции работают по-разному с целыми и вещественными числами.
Например, по правилам Котлина 5 / 2 даёт **2** (деление целых чисел),
но 5.0 / 2 (или 5 / 2.0) даёт 2.5 (деление вещественных чисел).

=== Имена

В приведённых примерах **f** являлось именем функции, а **x** -- именем её параметра.
По правилам языка Котлин, любое __имя__ обязано начинаться с буквы или символа **&lowbar;** и
может состоять из букв, цифр и символа **&lowbar;**.
Следует помнить, что Котлин **различает** строчные и прописные буквы;
рекомендуется всегда начинать имена параметров и функций со строчной буквы, а имена типов -- с прописной буквы.
Имя, состоящее из нескольких слов, обычно записывается в так называемой camel case нотации, например **bigNumber**.
Не рекомендуется:

 * использование букв не из латинского алфавита, например **имя**;
 * использование символа **&lowbar;** и цифр в именах, например **flag&lowbar;123**;
 * использование транслитерации в именах, например **dlina**.

=== Литералы

__Литералами__ в программировании называются константы, записываемые прямо в тексте программы
и не имеющие отдельных имён. У любого литерала имеется тип, определяемый по его записи.
Примеры литералов в Котлине:

 * -7, 0, 42 -- литералы типа Int;
 * 0.0, 3.14 или 6.67e-11 -- литералы типа Double, **обязаны** иметь как целую, так и дробную часть, запись с символом **e** означает 6.67 * 10^-11^;
 * **true** или **false** -- литералы типа Boolean
 * 'Z' -- литерал типа Char, необходимо использовать простые одинарные кавычки;
 * "name" -- литерал типа String, необходимо использовать простые двойные кавычки.

Ещё раз повторим, что Int и Double -- два принципиально разных типа,
а значит, 3 и 3.0 -- два принципиально разных числовых литерала.
В частности, деление целого числа на 3 будет происходить нацело и даст целый результат,
а деление целого числа на 3.0 даёт уже вещественный результат.

=== Математические функции

В библиотеке Java определено большое количество математических __функций__,
предназначенных для выполнения более сложных операций.
Для примера их использования рассмотрим решение задачи вычисления дискриминанта квадратного уравнения.
Математически он равен квадратному корню из b^2^-4ac.
Для расчёта b^2^ применим **уже написанную** выше функцию **sqr(x: Double)**,
а для вычисления квадратного корня -- готовую математическую функцию **sqrt(x: Double)** из библиотеки Java.

[source,kotlin]
----
// Решаем a*x*x + b*x + c = 0
fun discriminant(a: Double, b: Double, c: Double) = Math.sqrt(sqr(b) - 4 * a * c)
----

Обратите внимание на нотацию **Math.** перед именем функции **sqrt**.
Поскольку готовых функций существует очень много, они разбиты на так называемые __пакеты__ и __классы__ внутри пакетов.
**Math.sqrt** является **полным** именем функции вычисления квадратного корня, а **sqrt** -- её **коротким** именем.
Из-за неудобства работы с полными именами, чаще используется следующая запись:

[source,kotlin]
----
// Разрешение использовать короткие имена для всех функций из класса Math, находящегося в пакете java.lang
import java.lang.Math.*
// Решаем a*x*x + b*x + c = 0
fun discriminant(a: Double, b: Double, c: Double) = sqrt(sqr(b) - 4 * a * c)
----

Примеры других функций из **java.lang.Math**:

 * abs(x: Int) или abs(x: Double) -- модуль
 * sqrt(x: Double) -- квадратный корень
 * pow(x: Double, y: Double) -- возведение в степень x^y^
 * sin(x: Double) -- синус, cos(x: Double) -- косинус, tan(x: Double) -- тангенс, все три функции принимают x в радианах
 * exp(x: Double) -- экспонента e^x^
 * log(x: Double), log10(x: Double) -- соответственно натуральный и десятичный логарифм
 * min(x: Int, y: Int) или min(x: Double, y: Double) -- минимум из двух чисел
 * max(x: Int, y: Int) или max(x: Double, y: Double) -- максимум из двух чисел

=== Переменные в функциях

Выше мы рассмотрели два примера с функциями **sqr** и **discriminant**,
вычисление результата в которых занимало одну строчку кода.
Однако, в программировании это скорее редкий случай;
гораздо чаще расчёт результата функции предполагает реализацию некоторой последовательности вычислений -- алгоритма.
Для сохранения результатов **промежуточных** вычислений программисты придумали __переменные__.

Рассмотрим, например, задачу вычисления **произведения** двух корней квадратного уравнения.
Напомним, что корни квадратного уравнения вычисляются как (-b+d)/(2a) и (-b-d)/(2a) соответственно,
где d -- дискриминант квадратного уравнения.
При вычислении произведения удобно вначале сохранить вычисленный дискриминант в переменной **d**,
вычислить оба корня **x1** и **x2** и уже потом рассчитать их произведение.
На Котлине это записывается следующим образом:

[source,kotlin]
----
fun quadraticRootProduct(a: Double, b: Double, c: Double): Double /* тип обязателен */ {
    // Тело функции в виде блока
    val d = discriminant(a, b, c)
    val x1 = (-b + d) / (2 * a)
    val x2 = (-b - d) / (2 * a)
    return x1 * x2 // Результат
}
----

В этом примере тело функции записано в виде __блока__ в фигурных скобках,
в противоположность телу в виде __выражения__ -- как в функциях **sqr** и **discriminant** выше.
Знак равенства при этом убирается и обязательно указывается тип результата функции.
В примере присутствуют три промежуточные __переменные__ -- **d**, **x1**, **x2**.
Определение обычной __переменной__ в Котлине начинается с __ключевого слова__ **val**,
за которым следует имя переменной и, после знака равенства -- её значение.
При желании можно также указать тип переменной, например:

[source,kotlin]
----
    // ...
    val d: Double = discriminant(a, b, c)
----

Блок состоит из так называемых __операторов__ (в примере их четыре), выполняющихся по порядку сверху вниз.
**Прежде** чем использовать какую-либо переменную, её следует определить. Например, такая запись привела бы к ошибке:

[source,kotlin]
----
fun quadraticRootProduct(a: Double, b: Double, c: Double): Double {
    val x1 = (-b + d) / (2 * a) // Unresolved reference: d
    val x2 = (-b - d) / (2 * a) // Unresolved reference: d
    val d = discriminant(a, b, c)
    return x1 * x2 // Результат
}
----

Последний оператор функции, начинающийся с __ключевого слова__ **return**, определяет значение её результата.
Функция **quadraticRootProduct** в первую очередь вычислит значение переменной **d**,
используя **другую функцию** **discriminant**.
Затем произойдёт вычисление переменных **x1** и **x2** и лишь в конце -- вычисление результата в операторе **return**.

Для сравнения, приведём запись той же функции, не использующей переменные:
[source,kotlin]
----
fun quadraticRootProduct(a: Double, b: Double, c: Double) =
        ((-b + discriminant(a, b, c)) / (2 * a)) * (-b - discriminant(a, b, c)) / (2 * a))
----

Хотя и записанная в одну строчку, такая функция является гораздо менее понятной,
при её написании легко запутаться при расстановке скобок.
Кроме того, в ней происходит двухкратное вычисление значения дискриминанта, чего следует избегать.