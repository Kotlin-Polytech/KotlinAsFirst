= 1. Простые функции

Функцией в программировании называется законченный участок программы, решающий определённую задачу --
обычно это часть большой задачи, которую решает программа в целом,
хотя в простых случаях написание программы сводится к написанию одной функции.
Как и у функции в математическом смысле, у функции в программировании есть входы (параметры), выход (результат)
и определение, указывающее, как рассчитывается значение выхода по заданным значениям входов.

Определение простых функций на Котлине мало отличается от определения математических функций.
Рассмотрим для примера математическую функцию sqr(x) = x^2^. На Котлине она будет записана так:

[source,kotlin]
----
fun sqr(x: Int) = x * x
// или
fun sqr(x: Double) = x * x
----

В этом определении **fun** является __ключевым словом__, с которого начинается определение любой функции в Котлине;
**fun** является сокращением от function -- функция.
`sqr` -- это __имя__ функции, `x` -- __параметр__ функции,
`= x * x` -- __тело__ функции, определяющее, как следует вычислять её __результат__.
Имя функции вместе с её параметрами и ключевым словом **fun** называется её __заголовком__.

Поскольку __операция__ вычисления квадрата числа в Котлине отсутствует, результат вычисляется как произведение `x * x`.
В Котлине присутствуют ещё ряд стандартных __операций__, перечислим некоторые из них:

 * &plus; сложение;
 * - вычитание;
 * * умножение;
 * / деление;
 * % остаток от деления;
 * () круглые скобки для повышения приоритета операций.

Строчка, начинающаяся с символов **//**, является так называемым комментарием -- он предназначен
для лучшего понимания текста программы человеком и никак не влияет на поведение функции или программы.
В Котлине возможны также скобочные комментарии, например:

[source,kotlin]
----
/*
 Здесь будет длинная и сложная функция
 с несколькими параметрами
*/

// Скобочный комментарий начинается с символов /* и заканчивается символами */
----

== Типы параметров / результата функций

Нотация `: Int` или `: Double` задаёт так называемый __тип__ параметра `x` и требует пояснения.
__Тип__ в программировании подобен области допустимых значений в математике;
математически, запись `x: Int` близка к записи x &isin; Z, а `x: Double` соответственно x &isin; R.
Присутствие в определении функции типов параметров в Котлине **обязательно**;
наличие типов позволяет функции "понять", для каких входов она применима,
а для каких её использование является ошибкой.

Заметим, что __тип__ имеется не только у параметров функции, но и у её результата.
Полная запись функции возведения в квадрат в Котлине (для целого параметра) выглядит следующим образом:

[source,kotlin]
----
fun sqr(x: Int): Int = x * x
----

Здесь нотация `: Int` перед знаком равенства задаёт тип результата функции.
В Котлине в некоторых случаях **необязательно** записывать тип результата функции явно,
поскольку функция сама может __вывести__ этот тип, зная типы своих параметров.
В данном случае известно, что произведение целого числа на целое также даст целое число,
что позволяет использовать сокращённую форму записи без указания типа результата.

В Котлине определяется некоторое количество стандартных типов;
помимо них, программист имеет право определять свои типы, используя так называемые __классы__ (о них речь пойдёт позже).
На первых порах нам потребуются следующие стандартные типы:

 * Int -- целое число в диапазоне от -2^31^ до 2^31^-1;
 * Double -- вещественное число в диапазоне (примерно) от -1.7 * 10^308^ до 1.7 * 10^308^, имеющее точность в (примерно) 15 десятичных цифр;
 * Boolean -- так называемый __логический__ или __булевский__ тип с ровно двумя возможными значениями -- **true** и **false**;
 * Char -- символ (одиночный), например `Z` или `Я`; значением может являться любой символ, присутствующий в таблице "Unicode", с кодом от 0 до 2^16^-1;
 * String -- строка, состоящая из любого количества одиночных символов. Строка может быть пустой, то есть не содержать ни одного символа `""`

Целые и вещественные числа устроены по-разному.
Например, целые числа сохраняются в памяти компьютера **точно**, а вещественные числа -- **приближённо**.
Некоторые операции и функции работают по-разному с целыми и вещественными числами.
Например, по правилам Котлина `5 / 2` даёт `2` (деление целых чисел),
но `5.0 / 2` (или `5 / 2.0`) даёт `2.5` (деление вещественных чисел).

== Имена

В приведённых примерах `sqr` являлось именем функции, а `x` -- именем её параметра.
По правилам языка Котлин, любое __имя__ обязано начинаться с буквы или символа **&lowbar;** и
может состоять из букв, цифр и символа **&lowbar;**.
Следует помнить, что Котлин **различает** строчные и прописные буквы;
рекомендуется всегда начинать имена параметров и функций со строчной буквы, а имена типов -- с прописной буквы.
Имя, состоящее из нескольких слов, обычно записывается в так называемой camel case нотации, например `bigNumber`.
Не рекомендуется:

 * использование букв не из латинского алфавита, например `имя`;
 * использование символа **&lowbar;** и цифр в именах, например `flag&lowbar;123`;
 * использование транслитерации в именах, например `dlina`.

== Литералы

__Литералами__ в программировании называются константы, записываемые прямо в тексте программы
и не имеющие отдельных имён. У любого литерала имеется тип, определяемый по его записи.
Примеры литералов в Котлине:

 * -7, 0, 42 -- литералы типа Int;
 * 0.0, 3.14 или 6.67e-11 -- литералы типа Double, **обязаны** иметь как целую, так и дробную часть, запись с символом **e** означает 6.67 * 10^-11^;
 * **true** или **false** -- литералы типа Boolean
 * 'Z' -- литерал типа Char, необходимо использовать простые одинарные кавычки;
 * "name" -- литерал типа String, необходимо использовать простые двойные кавычки.

Ещё раз повторим, что Int и Double -- два принципиально разных типа,
а значит, 3 и 3.0 -- два принципиально разных числовых литерала.
В частности, деление целого числа на 3 будет происходить нацело и даст целый результат,
а деление целого числа на 3.0 даёт уже вещественный результат.

== Математические функции

В библиотеке Java определено большое количество математических __функций__,
предназначенных для выполнения более сложных операций.
Для примера их использования рассмотрим задачу решения квадратного уравнения ax^2^ + bx + c = 0.

Напомним, что корни квадратного уравнения ищутся по формуле x~1,2~ = (-b &plusmn; &radic;d) / (2a),
где d -- дискриминант квадратного уравнения -- вычисляется как d = b^2^-4ac.
Мы решим эту задачу в упрощённом виде -- найти какой-нибудь из двух возможных корней, скажем, тот,
в котором в числителе используется знак плюс.

Для начала напишем функцию для расчёта дискриминанта (она ещё пригодится нам в будущем).
Для расчёта b^2^ применим **уже написанную** выше функцию `sqr(x: Double)`.

[source,kotlin]
----
fun discriminant(a: Double, b: Double, c: Double) = sqr(b) - 4 * a * c
----

В приведённой записи `b` является __аргументом__ функции `sqr`.
Запись вида `sqr(b)` называется __вызовом__ функции `sqr`.
Подчеркнём отличие __параметра__ и __аргумента__ -- параметр определяется **внутри** функции и имеет определённое имя,
в данном случае `x`,
а аргумент передаётся в функцию **снаружи** и может являться как именем переменной, так и более сложным __выражением__.

Теперь напишем функцию для поиска корня квадратного уравнения.
Для вычисления квадратного корня применим готовую математическую функцию `sqrt(x: Double)`
из математической библиотеки Котлина.

[source,kotlin]
----
fun quadraticEquationRoot(a: Double, b: Double, c: Double) =
        (-b + kotlin.math.sqrt(discriminant(a, b, c))) / (2 * a)
----

Здесь мы, в свою очередь, используем **уже написанную** функцию `discriminant` для поиска дискриминанта,
и выражение `discriminant(a, b, c)`, то есть дискриминант уравнения, является __аргументом__ функции `sqrt`.
Это как раз тот случай, когда аргумент является сложным __выражением__.

Обратите внимание на нотацию `kotlin.math.` перед именем функции `sqrt`.
Поскольку готовых функций существует очень много, они разбиты на так называемые __пакеты__ и __классы__ внутри пакетов.
`kotlin.math.sqrt` является **полным** именем функции вычисления квадратного корня, а `sqrt` -- её **коротким** именем.
Из-за неудобства работы с полными именами, чаще используется следующая запись:

[source,kotlin]
----
// Разрешение использовать короткие имена для ВСЕХ функций из пакета kotlin.math
import kotlin.math.*

fun quadraticEquationRoot(a: Double, b: Double, c: Double) =
        (-b + sqrt(discriminant(a, b, c))) / (2 * a)
----

Здесь **import** -- так называемая __директива__ импорта имён, смысл её пояснён в комментарии.

Примеры других функций из `kotlin.math`:

 * abs(x: Int) или abs(x: Double) -- модуль;
 * sqrt(x: Double) -- квадратный корень;
 * Double.pow(x: Double) -- возведение в степень x^y^, используется как `x.pow(y)`;
 * sin(x: Double) -- синус, cos(x: Double) -- косинус, tan(x: Double) -- тангенс, все три функции считают, что `x` задан в радианах;
 * exp(x: Double) -- экспонента e^x^;
 * log(x: Double), log10(x: Double) -- соответственно натуральный и десятичный логарифм;
 * min(x: Int, y: Int) или min(x: Double, y: Double) -- минимум из двух чисел;
 * max(x: Int, y: Int) или max(x: Double, y: Double) -- максимум из двух чисел.

В том же пакете `kotlin.math` определены константы ``PI = 3.14...`` и ``E = 2.718...``.

== Переменные в функциях

Выше мы рассмотрели примеры с функциями `sqr`, `discriminant` и `sqRoot`,
вычисление результата в которых занимало одну строчку кода.
Однако, в программировании это скорее редкий случай;
гораздо чаще расчёт результата функции предполагает реализацию некоторой последовательности вычислений -- алгоритма.
Для сохранения результатов **промежуточных** вычислений программисты придумали __переменные__.

Рассмотрим, например, задачу вычисления **произведения** двух корней квадратного уравнения.
Напомним, что корни квадратного уравнения вычисляются как (-b+&radic;d)/(2a) и (-b-&radic;d)/(2a) соответственно,
где d -- дискриминант квадратного уравнения.
При вычислении произведения удобно вначале сохранить вычисленный корень из дискриминанта в переменной `sd`,
так как он используется при вычислении обоих корней.
Затем нужно вычислить оба корня `x1` и `x2` и уже потом рассчитать их произведение.
На Котлине это записывается следующим образом:

[source,kotlin]
----
fun quadraticRootProduct(a: Double, b: Double, c: Double): Double /* тип обязателен */ {
    // Тело функции в виде блока
    val sd = sqrt(discriminant(a, b, c))
    val x1 = (-b + sd) / (2 * a)
    val x2 = (-b - sd) / (2 * a)
    return x1 * x2 // Результат
}
----

В этом примере тело функции записано в виде __блока__ в фигурных скобках,
в противоположность телу в виде __выражения__ -- как в функциях `sqr` и `discriminant` выше.
Знак равенства при этом убирается и обязательно указывается тип результата функции.
В примере присутствуют три промежуточные __переменные__ -- `d`, `x1`, `x2`.
Определение промежуточной __переменной__ в Котлине начинается с __ключевого слова__ **val**
(сокращение от value -- значение), за которым следует имя переменной и, после знака равенства -- её значение.
При желании можно также указать тип переменной, например:

[source,kotlin]
----
    // ...
    val sd: Double = sqrt(discriminant(a, b, c))
----

Если тип переменной не указан, он определяется автоматически, например,
в данном случае он совпадёт с типом результата функции `sqrt`.

Блок состоит из так называемых __операторов__ (в примере их четыре), выполняющихся по порядку сверху вниз.
**Прежде** чем использовать какую-либо переменную, её следует определить. Например, такая запись привела бы к ошибке:

[source,kotlin]
----
fun quadraticRootProduct(a: Double, b: Double, c: Double): Double {
    val x1 = (-b + sd) / (2 * a) // Unresolved reference: sd
    val x2 = (-b - sd) / (2 * a) // Unresolved reference: sd
    val sd = sqrt(discriminant(a, b, c))
    return x1 * x2 // Результат
}
----

Последний оператор функции, начинающийся с __ключевого слова__ **return**, определяет значение её результата;
**return** переводится с английского как **вернуть** (результат).
Функция `quadraticRootProduct` в первую очередь вычислит значение переменной `sd`,
используя **другие функции** `discriminant` и `sqrt`.
Затем произойдёт вычисление переменных `x1` и `x2` и лишь в конце -- вычисление результата в операторе **return**.

Для сравнения, приведём запись той же функции, не использующей переменные:
[source,kotlin]
----
fun quadraticRootProduct(a: Double, b: Double, c: Double) =
        ((-b + sqrt(discriminant(a, b, c))) / (2 * a)) * ((-b - sqrt(discriminant(a, b, c))) / (2 * a))
----

Хотя и записанная в одну строчку, такая функция является гораздо менее понятной,
при её написании легко запутаться при расстановке скобок.
Кроме того, в ней происходит двухкратное вычисление корня из дискриминанта, чего следует избегать.

== Функция println и строковые шаблоны

Начнём с примера -- функции, решающей квадратное уравнение и демонстрирующей решение пользователю.

[source,kotlin]
----
fun solveQuadraticEquation(a: Double, b: Double, c: Double) /* no result */ {
    val sd = sqrt(discriminant(a, b, c))
    val x1 = (-b + sd) / (2 * a)
    val x2 = (-b - sd) / (2 * a)
    // Вывод на экран значений x1 и x2
    println(x1)
    println(x2)
    // Вывод на экран строки вида x1 = 3.0 x2 = 2.0
    println("x1 = $x1 x2 = $x2")
    // Вывод на экран произведения корней
    println("x1 * x2 = ${x1 * x2}")
}
----

Здесь мы подходим к такой важной части программирования,
как взаимодействие с пользователем и вообще с внешним для программы миром.
Обратите внимание -- в этот момент используемые нами функции начинают отличаться от чисто математических,
так как у них появляются __побочные эффекты__ (side effects).
Функция в программировании в общем случае не сводится __только__ к зависимости между параметрами и результатом.

Функция `println(p)` определена в стандартной библиотеке языка Котлин и не требует подключения каких-либо пакетов.
Её параметр `p` может иметь любой тип --
так, вызов `println(x1)` выведет на отдельную строку __консоли__ значение переменной `x1`.
Чаще всего, однако, `p` является строкой, например, `"x1 = $x1 x2 = $x2"`.
В данной строке присутствуют строковые шаблоны `$x1` и `$x2`, состоящие из символа **$** и имени переменной (параметра).
Вместо них программа автоматически подставит значение соответствующих переменных.
Строковый шаблон позволяет также подставить значение сложного выражения,
как, например, здесь: `"x1 * x2 = ${x1 * x2}"`.
В этом случае выражение записывается в фигурных скобках, чтобы программа имела возможность отследить его начало и конец.

Обратите внимание, что тип результата функции `solveQuadraticEquation` не указан.
Это означает, что функция **не имеет** результата (в математическом смысле).
Такие функции встречаются довольно часто, один из примеров -- сама функция `println`,
и их реальный результат сводится к побочным эффектам -- например, выводу на консоль.

Осталось определить -- что же такое __консоль__?
В привычной нам операционной системе Windows __консоль__ -- это окно или же его часть,
которую программа использует для вывода текстовой информации.
В Intellij IDEA данное окно можно открыть последовательностью команд `View` -> `Tool windows` -> `Run`.
При запуске программы из операционной системы она сама откроет так называемое "окно терминала",
которое будет использоваться программой для вывода текстовой информации.

== Главная функция

Наличие главной функции превращает набор отдельных функций в __программу__, которую можно **запустить**.
Выполнение __программы__ начинается с вызова её главной функции из операционной системы.
На Котлине главная функция определяется так:

[source,kotlin]
----
fun main(args: Array<String>) {
    // Решаем x^2 - 3*x + 2 = 0
    val x1x2 = quadraticRootProduct(1.0, -3.0, 2.0)
    println("Root product: $x1x2")
}
----

Единственный параметр `args` главной функции имеет тип `Array<String>`, то есть __массив__ строк.
О массивах и об использовании параметра `args` главной функции мы поговорим позже.
Результата главная функция не имеет. По правилам Котлина (и Java) она всегда обязана называться `main`.
Для быстрого ввода заголовка главной функции в Intellij IDEA можно ввести в редакторе специальную строку **psvm**
с последующим нажатием клавиши **Enter**.

Данная короткая программа использует функцию `quadraticRootProduct`, определённую выше,
для вычисления произведения корней квадратного уравнения, после чего выводит это произведение на консоль.
Для того чтобы её запустить, в Intellij IDEA достаточно щёлкнуть мышью на зелёный треугольник
слева от заголовка функции `main`.
Поскольку корни данного уравнения равны 1.0 и 2.0, после запуска программы на консоли мы увидим строчку

----
Root product: 2.0
----

== Тестовые функции

Тестовые функции -- особый вид функций, предназначенных для проверки правильности работы других функций.
Поскольку человеку свойственно ошибаться, программисты изобрели немало способов,
как можно проконтролировать правильность программы, как своей собственной, так и написанной другими людьми.
Тестовые функции являются одним из таких способов. Рассмотрим пример:

[source,kotlin]
----
// Разрешение использовать короткое имя аннотации org.junit.jupiter.api.Test
import org.junit.jupiter.api.Test
// Разрешение использовать короткое имя для функции org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertEquals

// Класс Tests, наличие класса обязательно для библиотеки JUnit
class Tests {

    // ...

    // Тестовая функция
    @Test
    fun testSqr() {
        assertEquals(0, sqr(0))  // Проверить, что квадрат нуля это 0
        assertEquals(4, sqr(2))  // Проверить, что квадрат двух это 4
        assertEquals(9, sqr(-3)) // Проверить, что квадрат -3 это 9
    }
}
----

Написание тестовых функций требует подключения к программе одной из библиотек автоматического тестирования,
например, библиотеки **JUnit**.
Большинство классов этой библиотеки находятся в пакете `org.junit` для версии JUnit 4.x или
в пакете `org.junit.jupiter.api` для версии JUnit 5.х.

`@Test` -- это так называемая __аннотация__, то есть, пометка, используемая для придания функции `testSqr`
дополнительного смысла. В данном случае, аннотация делает функцию `testSqr` тестовой.
Функция `assertEquals` предназначена для сравнения результата вызова некоторой другой функции,
например, `sqr`, с ожидаемым. В приведённом примере она вызывается трижды.

Тестовых функций в проекте может быть много, любая из них запускается так же, как и главная функция --
нажатием зелёного треугольника слева от заголовка функции.
Тестовые функции выполняются по тем же принципам, что и любые другие,
но вызовы `assertEquals` происходят особым образом:

 * если проверка показала совпадение результата с ожидаемым, функция не делает ничего;
 * в противном случае выполнение тестовой функции завершается и в IDEA появится сообщение, выделенное красным цветом, о неудачном завершении тестовой функции.

Если тестовая функция завершила работу и результаты всех проверок совпали с ожидаемыми,
тестовая функция считается завершившейся успешно.

Наконец, что же такое `class Tests`?
По правилам библиотеки JUnit, все тестовые функции обязаны находиться внутри какого-либо __класса__.
О том, для чего нужны классы, мы поговорим позднее.
В данном примере для этой цели был создан класс с именем `Tests` (имя может быть произвольным),
и тестовая функция была записана в нём.
Зелёный треугольник напротив имени класса позволяет одновременно запустить все тестовые функции в данном классе.

Любая написанная программа или функция **всегда** требует проверки.
Это требование тем важнее, чем сложнее программа или функция.
Тестовые функции позволяют доказать правильность работы проверяемой функции, по крайней мере,
для некоторых значений её аргументов.

Наряду с тестовыми функциями, может быть использовано и __ручное__ тестирование.
Ручное тестирование предполагает вывод результатов функции на консоль и ручную проверку их с ожидаемыми.
Для ручного тестирования может быть использована главная функция, например:

[source,kotlin]
----
fun main(args: Array<String>) {
    println("sqr(0) = ${sqr(0)}")
    println("sqr(4) = ${sqr(4)}")
}
----

В нормальном случае мы должны увидеть на консоли строчки

----
sqr(0) = 0
sqr(4) = 16
----

Ручное тестирование гораздо более трудоёмко и требует от программиста или тестировщика гораздо большего внимания.
Поэтому в современном программировании рекомендуется начинать проверку функций с создания тестовых функций,
которые запускаются каждый раз при изменении программы и позволяют заметить появившиеся ошибки.
Ручное тестирование выполняется существенно реже, обычно перед выпуском новой __версии__ программы. Но об этом позже...

== Отступление: о структуре полноценной программы

Большая программа на Котлине может состоять из любого количества файлов, каждый из которых, в свою очередь,
может содержать любое количество функций и объявлений другого вида (позже мы с ними познакомимся).
Объявленные функции могут использовать друг друга.
__Точками входа__, то есть функциями, с которых программа __начинает__ выполняться, являются главные функции `main`.
Программа может содержать любое количество главных функций.
Программа может не содержать их вообще, но в этом случае её не удастся запустить --
функции программы, однако, по-прежнему можно тестировать с помощью тестовых функций.
Когда написанная программа передаётся пользователю, она собирается и пакуется,
при этом указывается, с какой конкретно главной функции следует начать её исполнение.
Подробнее про упаковку программ можно прочитать вот здесь: https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html.

== Упражнения

Откройте файл `src/lesson1/task1/Simple.kt` в проекте `KotlinAsFirst`.
В файле перечислено некоторое количество задач на этот раздел в форме:

[source,kotlin]
----
/*
 * Решите такую-то задачу...
 */
fun doSomething(arg: Int): Int = TODO()
----

Выберите любую из задач. Придумайте её решение и замените `= TODO()`
на тело функции с записью вашего алгоритма (в форме выражения либо в форме блока на ваш выбор).
Важно: не следует при этом менять имя функции, количество, имена и типы параметров, тип результата.

Откройте затем файл `test/lesson1/task1/Tests.kt`,
найдите в нём тестовую функцию -- её название должно совпадать с названием написанной вами функции.
Щёлкните мышью на зелёный значок запуска теста, в нижней части окна IDEA появится окно тестирования.
Если задача решена верно, вы увидите в этом окне зелёную надпись All Tests Passed,
в противном случае -- 1 test failed с описанием проблемы вида:

----
java.lang.AssertionError:
Expected : <something>
Actual   : <another>
----

Ниже вы увидите ссылку на строчку тестовой функции, проверка в которой оказалась неудачной.
Expected -- это ожидаемое значение результата, а Actual -- реально полученное.
Исправьте все ошибки и добейтесь прохождения теста.

Внутри файла `src/lesson1/task1/Simple.kt` добавьте главную функцию `main`.
Вызовите в ней написанную вами функцию с произвольными аргументами и выведите результат на консоль с помощью `println`,
например:

[source,kotlin]
----
fun main(args: Array<String>) {
    val result = doSomething(42)
    println("Result: $result")
}
----

Запустите главную функцию. Убедитесь, что результат совпадает с ожидаемым вами.

Решите несколько других задач из того же файла.
Убедитесь в том, что можете их решать уверенно и без посторонней помощи.
После этого вы можете перейти к следующему разделу.

Примечание: система Котоед начисляет баллы за уроки по принципу "сумма двух лучших задач".
Для первого урока рекомендуется ориентироваться на сумму в 4-5 баллов.
