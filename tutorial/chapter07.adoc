= 7. Классы и интерфейсы

В этом разделе мы плавно переходим от простых классов к более сложным.
На самом деле, прямого разграничения классов на "простые" и "сложные" не существует;
сложность класса приблизительно определяется количеством его свойств и функций.

С постепенным усложнением класса, его описание начинает увеличиваться в объёме.
Кроме этого, могут появиться несколько вариантов выполнения классом тех или иных действий.
Начиная с этого момента, есть смысл задуматься об отдельных ответах на вопросы "Что делает объект" и "Как он это делает".
В Котлине, ответ на первый вопрос дают __интерфейсы__ (**interface**), на второй -- __классы__ (**class**).

== Интерфейсы

Интерфейс определяет, что должен уметь делать объект.
С точки зрения Котлина, это набор свойств (с их типами) и функций (с их параметрами и результатом),
которые должны у этого объекта иметься.

Рассмотрим в качестве примера матрицу, то есть прямоугольную таблицу, имеющую M рядов и N колонок.
В совокупности, матрица имеет `M * N` ячеек, в каждой из которых хранится элемент матрицы определённого типа.
Будет считать, что типы всех элементов матрицы совпадают.
В этом случае, определение __интерфейса__ матрицы на Котлине может выглядеть так:

[source,kotlin]
----
data class Cell(val row: Int, val column: Int)

interface Matrix<E> {
    val height: Int
    val width: Int

    operator fun get(row: Int, column: Int): E
    operator fun get(cell: Cell): E

    operator fun set(row: Int, column: Int, value: E)
    operator fun set(cell: Cell, value: E)
}
----

Здесь `Cell` -- элементарный класс с данными для хранения координат (ряд, колонка) определённой ячейки матрицы.
Заголовок `interface Matrix<E>` определяет интерфейс с именем **Matrix**, использующий __настраиваемый тип__ `E`.
Никаких ограничений на этот тип не задано, поэтому он может быть произвольным.
В данном случае предполагается, что все элементы матрицы имеют тип `E`.

Свойства `height` и `width` определяют высоту (число рядов) и ширину (число колонок) матрицы.
Это целые числа, но значения их не заданы, поскольку интерфейс определяет лишь, **что** есть у матрицы.
Две операторных функции `get` предназначены для определения содержимого определённой ячейки матрицы
(для удобства, одна из них работает с двумя целочисленными параметрами, другая -- с одним параметром-ячейкой).
Результат обеих функций имеет тип `E` (поскольку элементы имеют этот тип), но **как** он определяется --
в интерфейсе опять-таки неизвестно.

Наконец, операторные функции `set` предназначены для замены содержимого определённой ячейки матрицы.
Их последний параметр содержит элемент, который нужно записать в заданную ячейку.
Результат у данных функций отсутствует, но они меняют внутреннее состояние матрицы, то есть имеют побочный эффект.
Вызывать `set` можно как непосредственно, так и с помощью индексации:
`matrix[cell] = value` эквивалентно `matrix.set(cell, value)`.
Как `get`, так и `set` предполагаеют, что номер ряда лежит в диапазоне `0..height - 1`,
а номер колонки в диапазоне `0..width - 1`.

Интерфейсы определяют новый тип или множество типов -- в данном случае `Matrix<E>` -- но не имеют конструкторов.
Имея только интерфейс, создать объект данного типа нельзя.
Тем не менее, имея только интерфейс, можно определять различные операции над уже имеющимся объектом.
Например, следующая функция меняет знак всех элементов целочисленной матрицы на обратный:

[source,kotlin]
----
fun invertMatrix(matrix: Matrix<Int>) {
    for (row in 0..matrix.height - 1) {
        for (column in 0..matrix.width - 1) {
            matrix[row, column] = -matrix[row, column]
        }
    }
}
----

Заметьте, что здесь мы ничего не знаем о внутреннем устройстве матрицы и никак не используем информацию о нём.
Сам код достаточно тривиален и не требует особых объяснений.
Оператор `matrix[row, column] = -matrix[row, column` использует сразу обе операторные функции `get`, `set`
и эквивалентен следующему: `matrix.set(row, column, -matrix.get(row, column))`.

В примере, интерфейс включает в себя только свойства без значений и функции без реализаций. 
Это довольно частый случай, но, вообще говоря, в нём могут присутствовать и свойства со значениями, и функции с реализациями.
Например:

[source,kotlin]
----
interface Matrix<E> {
    val height: Int
    val width: Int

    operator fun get(row: Int, column: Int): E
    operator fun get(cell: Cell) = get(cell.row, cell.column)

    operator fun set(row: Int, column: Int, value: E)
    operator fun set(cell: Cell, value: E) = set(cell.row, cell.column, value)
}
----

Здесь в парах `get` / `set` первая из функций объявлена без реализации, а вторая использует первую.

Таким образом, интерфейсы позволяют описывать операции обобщённо, не задумываясь о внутренностях того или иного объекта.
Кроме этого, интерфейсы -- удобное средство для описания спецификаций, они позволяют заранее договориться о том,
что можно будет делать с тем или иным объектом. По этим причинам, интерфейсы широко используются в программировании.

Неискушённого читателя это может удивить, но типы `List<T>` и `MutableList<T>`, так же, как и
`Set<T>`, `MutableSet<T>`, `Collection<T>`, `MutableCollection<T>` -- все являются интерфейсами.
В описании списков ничего не говорится о том, как именно эти списки работают.
Например, существует две широко известные __реализации__ интерфейса `MutableList<T>` --
а именно, `ArrayList<T>` (список, реализованный на основе массива, в котором все элементы хранятся единым куском),
и `LinkedList<T>` (так называемый __связанный__ список, в котором каждый элемент содержит ссылку на следующий
и на предыдущий, при этом хранятся все элементы отдельно).
Но, имея `MutableList<T>`, мы не знаем, с какой конкретно из этих двух реализаций мы имеем дело,
а в случае `List<T>`, могут также присутствовать и дополнительные реализации для неизменяемого или пустого списка.

== Функции-создатели

Функции-создатели в некотором смысле являются заменой конструкторам.
Они предназначены для создания объекта, реализующего тот или иной интерфейс;
при этом, естественно, для их написания должна существовать реализация данного интерфейса
и функция-создатель обычно вызывает внутри себя тот или иной конструктор,
иногда делая выбор из нескольких вариантов.
Известными примерами функций-создателей являются `listOf(...)`, `mutableListOf(...)`, `setOf(...)`, `mutableSetOf(...)`.
Для матрицы, подобная функция может быть определена так:

[source,kotlin]
----
fun <E> createMatrix(height: Int, width: Int, e: E): Matrix<E> = TODO()
----

Здесь `fun <E>` говорит о том, что функция использует настраиваемый тип `E` -- тип элементов матрицы.
Первый и второй параметр задают высоту и ширину матрицы,
а третий -- значение элемента, который при создании матрицы будет записан во все ячейки.
Результатом функции должна стать вновь созданная матрица, но,
поскольку реализации интерфейса `Matrix<E>` ещё нет, вместо вызова конструктора в теле фигурирует `TODO()` --
специальная функция, бросающая исключение `UnsupportedOperationException`.

Имея функцию-создатель, мы можем описывать более сложные операции с матрицами,
которые не только изменяют существующие матрицы, но и создают новые -- по-прежнему не зная ничего о реализации.
Например, транспонирование меняет местами ряды и колонки в матрице:

[source,kotlin]
----
fun <E> transpose(matrix: Matrix<E>): Matrix<E> {
    if (matrix.width < 1 || matrix.height < 1) return matrix
    val result = createMatrix(height = matrix.width, width = matrix.height, e = matrix[0, 0])
    for (i in 0..matrix.width - 1) {
        for (j in 0..matrix.height - 1) {
            result[i, j] = matrix[j, i]
        }
    }
    return result
}
----

Так мы создаём новую матрицу, меняя местами ширину и высоту старой,
а затем в цикле переписываем элементы из старой матрицы в новую -- с учётом того, что ряды стали колонками и наоборот.

При попытке протестировать эту функцию мы получим исключение `UnsupportedOperationException`
при создании матрицы -- до тех пор, пока не сделаем её реализацию и не используем её в функции-создателе.

== Скелет реализации интерфейса

Для того, чтобы создать __реализацию__ интерфейса --
то есть __класс__, который умеет делать все описанные в интерфейсе операции --
необходимо для начала написать примерно следующий "скелет".

[source,kotlin]
----
class MatrixImpl<E> : Matrix<E> {
    override val height: Int = TODO()
    override val width: Int = TODO()

    override fun get(row: Int, column: Int): E  = TODO()
    override fun get(cell: Cell): E  = TODO()

    override fun set(row: Int, column: Int, value: E) {
        TODO()
    }
    override fun set(cell: Cell, value: E) {
        TODO()
    }

    override fun equals(other: Any?) = TODO()
    override fun toString(): String = TODO()
}
----

Заголовок `class MatrixImpl<E> : Matrix<E>` говорит о том, что мы определяем класс `MatrixImpl<E>`,
который является реализацией интерфейса `Matrix<E>` и использует __настраиваемый тип__ `E`.
Далее перечисляются все свойства и функции, имеющиеся в `Matrix<E>`;
перед каждым из них добавляется модификатор `override` --
он сигнализирует об определении свойства / функции, уже имеющихся в интерфейсе.
Класс, в отличие от интерфейса, должен содержать реальные тела функций и реальные значения свойств --
но в скелете они заменяются на `TODO()`.
В конце класса перечисляются две упоминавшиеся ранее функции `equals` и `toString` --
первая для сравнения (матриц) на равенство, а вторая для представления матрицы в виде строки.

Здесь въедливый читатель, заметив перед `equals` и `toString` модификатор `override`,
может задаться вопросом -- а две этих функции тоже определены в каком-нибудь интерфейсе?
Это предположение не вполне верно.
Определения двух этих функций имеются в специальном __классе__ `Any`, определяющем тип "любой".
Напомним, что в Котлине любой тип является разновидностью типа `Any?`,
то есть множество значений `Any?` -- вообще все значения, которые могут существовать в программе на Котлине.
`Any` без вопроса имеет то же множество значений, за вычетом специального **null**.
Это, в частности, значит,
что сравнение на равенство и представление в виде строки в Котлине можно выполнить для чего угодно.

== Варианты реализации интерфейса

Теперь поговорим о том, как можно скелет реализации заменить на настоящую реализацию. 
Почти всегда, когда речь идёт о более-менее сложных понятиях, это можно сделать несколькими способами,
какой из них лучше подходит для конкретной задачи -- решает программист.

Начать нужно всегда с ответа на вопрос -- какие данные описывают интересующий нас объект (матрицу)
и как их можно представить на данном языке программирования?
Для матрицы первая часть ответа такова -- высота и ширина матрицы (целые числа) и набор элементов матрицы (типа `E`).
Поскольку имеющиеся у матрицы функции не предполагают изменения её высоты и ширины, 
их лучше всего объявить как свойства в конструкторе матрицы:

[source,kotlin]
----
class MatrixImpl<E>(override val height: Int, override val width: Int/*, something other?*/) : Matrix<E> {
    // Attention: no more height / width here
    
    override fun get(row: Int, column: Int): E  = TODO()
    // Other functions...
}
----

Обратите внимание, что определения свойств высоты и ширины исчезли из тело класса и переехали в конструктор --
при этом сохранив необходимый модификатор `override`.

== Упражнения

Откройте файл `srс/lesson7/task1/Matrix.kt` в проекте `KotlinAsFirst`.
Он содержит определение интерфейса `Matrix<E>`, функции-создателя `createMatrix` и реализации `MatrixImpl<E>`.
Выберите один из рассмотренных выше вариантов реализаций матрицы и напишите определения ВСЕХ функций
в классе `MatrixImpl`, после чего напишите определение функции-создателя.
Протестируйте свою реализацию, используя тесты из `test/lesson7/task1/Tests.kt`.

Откройте теперь файл `srс/lesson6/task2/Matrices.kt`.
Файл содержит задачи на различные операции с матрицами, все они используют готовый интерфейс `Matrix<E>`.
С использованием данного интерфейса и функции-создателя, решите одну или несколько задач из этого файла.
Протестируйте свою реализацию, используя тесты из `test/lesson7/task2/Tests.kt`.
Многие задачи из этого файла сложны, особенно это касается двух последних задач про "Игру в 15".

Переходите к разделу 8.
